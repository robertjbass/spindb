/**
 * QuestDB restore module unit tests
 */

import { describe, it, after } from 'node:test'
import { join } from 'path'
import { writeFile, rm, mkdir } from 'fs/promises'
import { tmpdir } from 'os'
import { assert, assertEqual } from '../utils/assertions'
import {
  detectBackupFormat,
  parseConnectionString,
} from '../../engines/questdb/restore'

describe('QuestDB Restore Module', () => {
  const testDir = join(tmpdir(), 'questdb-test-' + Date.now())

  after(async () => {
    try {
      await rm(testDir, { recursive: true, force: true })
    } catch {
      // Ignore errors (e.g., ENOENT if already cleaned up)
    }
  })

  describe('detectBackupFormat', () => {
    it('should detect .sql file by extension', async () => {
      await mkdir(testDir, { recursive: true })
      const sqlPath = join(testDir, 'backup.sql')
      await writeFile(
        sqlPath,
        '-- QuestDB backup\nCREATE TABLE test (id LONG);',
      )

      const format = await detectBackupFormat(sqlPath)
      assertEqual(format.format, 'sql', 'Should detect as sql')
      assert(
        format.description.includes('SQL'),
        'Description should mention SQL',
      )

      await rm(sqlPath, { force: true })
    })

    it('should detect SQL content by patterns', async () => {
      await mkdir(testDir, { recursive: true })
      const backupPath = join(testDir, 'backup.bak')
      await writeFile(
        backupPath,
        'CREATE TABLE test (id LONG);\nINSERT INTO test VALUES (1);',
      )

      const format = await detectBackupFormat(backupPath)
      assertEqual(format.format, 'sql', 'Should detect SQL by content')

      await rm(backupPath, { force: true })
    })

    it('should detect QuestDB-specific SQL comments', async () => {
      await mkdir(testDir, { recursive: true })
      const backupPath = join(testDir, 'backup.bak')
      await writeFile(
        backupPath,
        '-- QUESTDB backup generated by SpinDB\nSELECT 1;',
      )

      const format = await detectBackupFormat(backupPath)
      assertEqual(format.format, 'sql', 'Should detect QuestDB SQL by comment')

      await rm(backupPath, { force: true })
    })

    it('should return unknown for non-SQL files', async () => {
      await mkdir(testDir, { recursive: true })
      const textPath = join(testDir, 'backup.txt')
      await writeFile(textPath, 'This is not a SQL backup')

      const format = await detectBackupFormat(textPath)
      assertEqual(format.format, 'unknown', 'Should detect as unknown')

      await rm(textPath, { force: true })
    })
  })

  describe('parseConnectionString', () => {
    it('should parse postgresql connection string', () => {
      const result = parseConnectionString(
        'postgresql://admin:quest@127.0.0.1:8812/qdb',
      )
      assertEqual(result.host, '127.0.0.1', 'Host should be 127.0.0.1')
      assertEqual(result.port, 8812, 'Port should be 8812')
      assertEqual(result.database, 'qdb', 'Database should be qdb')
      assertEqual(result.user, 'admin', 'User should be admin')
      assertEqual(result.password, 'quest', 'Password should be quest')
    })

    it('should parse postgres protocol', () => {
      const result = parseConnectionString(
        'postgres://admin:quest@localhost:8812/qdb',
      )
      assertEqual(result.host, 'localhost', 'Host should be localhost')
      assertEqual(result.port, 8812, 'Port should be 8812')
    })

    it('should use QuestDB default port when not specified', () => {
      const result = parseConnectionString('postgresql://admin@127.0.0.1/qdb')
      assertEqual(
        result.port,
        8812,
        'Default port should be 8812 (QuestDB default)',
      )
    })

    it('should parse connection string without password and use default', () => {
      const result = parseConnectionString(
        'postgresql://admin@127.0.0.1:8812/qdb',
      )
      assertEqual(result.user, 'admin', 'User should be admin')
      assertEqual(result.password, 'quest', 'Password should default to quest')
    })

    it('should throw for invalid connection string', () => {
      try {
        parseConnectionString('invalid')
        assert(false, 'Should have thrown')
      } catch (error) {
        assert(error instanceof Error, 'Should throw Error')
      }
    })

    it('should accept any protocol and parse it', () => {
      // The implementation normalizes questdb:// to postgresql:// and parses any URL
      const result = parseConnectionString(
        'questdb://admin:quest@127.0.0.1:8812/qdb',
      )
      assertEqual(result.host, '127.0.0.1', 'Host should be 127.0.0.1')
      assertEqual(result.port, 8812, 'Port should be 8812')
    })

    it('should throw for empty connection string', () => {
      try {
        parseConnectionString('')
        assert(false, 'Should have thrown')
      } catch (error) {
        assert(error instanceof Error, 'Should throw Error')
      }
    })
  })
})
