/**
 * QuestDB Backup Implementation
 *
 * QuestDB uses a custom backup format based on SQL exports.
 * Since QuestDB uses PostgreSQL wire protocol, we can use psql for backup
 * but QuestDB has its own SQL extensions for time-series data.
 *
 * Backup approach:
 * - Export table schemas using SHOW CREATE TABLE
 * - Export data using SELECT with proper ordering
 * - Output as standard SQL statements
 */

import { writeFile, stat } from 'fs/promises'
import { spawn } from 'child_process'
import { configManager } from '../../core/config-manager'
import { logDebug, logWarning } from '../../core/error-handler'
import type { ContainerConfig, BackupOptions, BackupResult } from '../../types'

/**
 * Execute a query against QuestDB using psql (PostgreSQL protocol)
 */
async function executeQuery(
  port: number,
  database: string,
  query: string,
): Promise<string> {
  // Try to find psql from config or PATH
  let psqlPath = await configManager.getBinaryPath('psql')
  if (!psqlPath) {
    // Fall back to system psql
    psqlPath = 'psql'
  }

  return new Promise((resolve, reject) => {
    const args = [
      '-h',
      '127.0.0.1',
      '-p',
      String(port),
      '-U',
      'admin',
      '-d',
      database,
      '-t', // Tuples only (no headers)
      '-A', // Unaligned output
      '-c',
      query,
    ]

    const proc = spawn(psqlPath!, args, {
      stdio: ['ignore', 'pipe', 'pipe'],
      env: { ...process.env, PGPASSWORD: 'quest' },
    })

    let stdout = ''
    let stderr = ''

    proc.stdout.on('data', (data: Buffer) => {
      stdout += data.toString()
    })
    proc.stderr.on('data', (data: Buffer) => {
      stderr += data.toString()
    })

    proc.on('close', (code) => {
      if (code === 0) {
        resolve(stdout.trim())
      } else {
        reject(new Error(`psql error: ${stderr || `exit code ${code}`}`))
      }
    })
    proc.on('error', (err) => {
      reject(new Error(`Failed to execute psql: ${err.message}`))
    })
  })
}

/**
 * Create a backup of a QuestDB database
 */
export async function createBackup(
  container: ContainerConfig,
  outputPath: string,
  options: BackupOptions,
): Promise<BackupResult> {
  const { port } = container
  const database = options.database || container.database || 'qdb'

  const lines: string[] = []
  lines.push('-- QuestDB backup generated by SpinDB')
  lines.push(`-- Database: ${database}`)
  lines.push(`-- Date: ${new Date().toISOString()}`)
  lines.push('')

  try {
    // Get list of tables
    const tablesQuery = `SELECT table_name FROM tables() WHERE table_name NOT LIKE 'sys.%'`
    const tablesResult = await executeQuery(port, database, tablesQuery)
    const tables = tablesResult.split('\n').filter((t) => t.trim())

    logDebug(`Found ${tables.length} tables in database ${database}`)

    for (const table of tables) {
      if (!table.trim()) continue

      lines.push(`-- Table: ${table}`)
      lines.push('')

      // Get CREATE TABLE statement
      try {
        const createQuery = `SHOW CREATE TABLE "${table}"`
        let createResult = await executeQuery(port, database, createQuery)
        if (createResult) {
          // QuestDB's SHOW CREATE TABLE uses single quotes for table names,
          // but SQL requires double quotes for identifiers. Fix the quoting.
          // Also, the output sometimes ends with ; already, avoid double ;;
          createResult = createResult
            .replace(/^CREATE TABLE '([^']+)'/, 'CREATE TABLE "$1"')
            .replace(/;$/, '') // Remove trailing semicolon if present
          lines.push(createResult + ';')
          lines.push('')
        }
      } catch (error) {
        logWarning(`Could not get CREATE TABLE for ${table}: ${error}`)
        continue
      }

      // Export table data
      try {
        // Try to get column names using table_columns() function
        // This ensures INSERT statements have explicit column names for reliability
        let columns: string[] = []
        let useExplicitColumns = false

        try {
          const columnsQuery = `SELECT column FROM table_columns('${table}')`
          const columnsResult = await executeQuery(port, database, columnsQuery)
          columns = columnsResult.split('\n').filter((c) => c.trim())
          useExplicitColumns = columns.length > 0
        } catch {
          // table_columns() failed - will use SELECT * without explicit column names
          logDebug(`Could not get columns for ${table}, using SELECT *`)
        }

        // Get the designated timestamp column (if any) for ordering
        // QuestDB tables have a designated timestamp column that can have any name
        let orderClause = ''
        try {
          const tsQuery = `SELECT designatedTimestamp FROM tables() WHERE table_name = '${table}'`
          const tsResult = await executeQuery(port, database, tsQuery)
          if (tsResult && tsResult.trim()) {
            orderClause = ` ORDER BY "${tsResult.trim()}"`
          }
        } catch {
          // No designated timestamp or query failed - export without ordering
        }

        // Build SELECT query - use explicit columns if available, otherwise SELECT *
        const columnList = useExplicitColumns
          ? columns.map((c) => `"${c}"`).join(', ')
          : '*'
        const dataQuery = `SELECT ${columnList} FROM "${table}"${orderClause}`
        const dataResult = await executeQuery(port, database, dataQuery)

        if (dataResult) {
          const rows = dataResult.split('\n').filter((r) => r.trim())
          lines.push(`-- Data for ${table}: ${rows.length} rows`)

          // Generate INSERT statements
          for (const row of rows) {
            // Parse the pipe-delimited output and convert to INSERT
            // Trim each value to handle Windows CRLF line endings
            const values = row.split('|').map((v) => {
              const trimmed = v.trim()
              if (trimmed === '' || trimmed === 'null') return 'NULL'
              // Check if value looks like a number (int or float)
              if (/^-?\d+(\.\d+)?$/.test(trimmed)) {
                return trimmed // Don't quote numbers
              }
              // Escape single quotes and wrap strings
              return `'${trimmed.replace(/'/g, "''")}'`
            })

            // Use explicit column names if available, otherwise positional VALUES
            if (useExplicitColumns) {
              lines.push(
                `INSERT INTO "${table}" (${columnList}) VALUES (${values.join(', ')});`,
              )
            } else {
              lines.push(
                `INSERT INTO "${table}" VALUES (${values.join(', ')});`,
              )
            }
          }
          lines.push('')
        }
      } catch (error) {
        logWarning(`Could not export data for ${table}: ${error}`)
      }
    }

    // Write backup file
    const content = lines.join('\n')
    await writeFile(outputPath, content, 'utf-8')

    // Get file size
    const stats = await stat(outputPath)

    return {
      path: outputPath,
      format: 'sql',
      size: stats.size,
    }
  } catch (error) {
    throw new Error(
      `Failed to create QuestDB backup: ${error instanceof Error ? error.message : String(error)}`,
    )
  }
}
