/**
 * ClickHouse backup module
 * Supports SQL-based backups using clickhouse client
 *
 * ClickHouse backup formats:
 * - SQL: DDL + INSERT statements (portable, human-readable)
 * - Native: ClickHouse native format (faster, compact)
 */

import { spawn } from 'child_process'
import { stat, mkdir, writeFile } from 'fs/promises'
import { existsSync, createWriteStream } from 'fs'
import { dirname } from 'path'
import { logDebug, logWarning } from '../../core/error-handler'
import { requireClickHousePath } from './cli-utils'
import type { ContainerConfig, BackupOptions, BackupResult } from '../../types'

/**
 * Execute a ClickHouse query and return the result
 */
async function execClickHouseQuery(
  clickhousePath: string,
  port: number,
  database: string,
  query: string,
): Promise<string> {
  return new Promise((resolve, reject) => {
    const args = [
      'client',
      '--host',
      '127.0.0.1',
      '--port',
      String(port),
      '--database',
      database,
      '--query',
      query,
    ]

    const proc = spawn(clickhousePath, args, {
      stdio: ['pipe', 'pipe', 'pipe'],
    })

    let stdout = ''
    let stderr = ''

    proc.stdout.on('data', (data: Buffer) => {
      stdout += data.toString()
    })
    proc.stderr.on('data', (data: Buffer) => {
      stderr += data.toString()
    })

    proc.on('error', reject)

    proc.on('close', (code) => {
      if (code === 0 || code === null) {
        resolve(stdout)
      } else {
        reject(new Error(stderr || `clickhouse client exited with code ${code}`))
      }
    })
  })
}

/**
 * Get list of tables in a database
 */
async function getTables(
  clickhousePath: string,
  port: number,
  database: string,
): Promise<string[]> {
  const result = await execClickHouseQuery(
    clickhousePath,
    port,
    database,
    `SELECT name FROM system.tables WHERE database = '${database}' ORDER BY name`,
  )
  return result
    .trim()
    .split('\n')
    .filter((t) => t.trim())
}

/**
 * Get CREATE TABLE statement for a table
 */
async function getCreateTableStatement(
  clickhousePath: string,
  port: number,
  database: string,
  table: string,
): Promise<string> {
  // Use TSVRaw format to get unescaped output (newlines as actual newlines, not \n)
  const result = await execClickHouseQuery(
    clickhousePath,
    port,
    database,
    `SHOW CREATE TABLE ${database}.${table} FORMAT TSVRaw`,
  )
  return result.trim()
}

/**
 * Create a SQL backup (DDL + INSERT statements)
 */
async function createSqlBackup(
  container: ContainerConfig,
  outputPath: string,
  database: string,
): Promise<BackupResult> {
  const { port, version } = container

  const clickhousePath = await requireClickHousePath(version)

  const lines: string[] = []
  lines.push('-- ClickHouse backup generated by SpinDB')
  lines.push(`-- Date: ${new Date().toISOString()}`)
  lines.push(`-- Database: ${database}`)
  lines.push('')

  // Get list of tables
  const tables = await getTables(clickhousePath, port, database)
  logDebug(`Found ${tables.length} tables to backup`)

  for (const table of tables) {
    lines.push(`-- Table: ${table}`)
    lines.push('')

    // Get CREATE TABLE statement
    try {
      const createStmt = await getCreateTableStatement(
        clickhousePath,
        port,
        database,
        table,
      )
      lines.push(createStmt + ';')
      lines.push('')
    } catch (error) {
      logWarning(`Could not get CREATE TABLE for ${table}: ${error}`)
      continue
    }

    // Export data using INSERT format
    try {
      const data = await execClickHouseQuery(
        clickhousePath,
        port,
        database,
        `SELECT * FROM ${database}.${table} FORMAT SQLInsert`,
      )
      if (data.trim()) {
        // SQLInsert format uses literal "table" as placeholder, replace with actual table name
        const insertData = data.trim().replace(/^INSERT INTO table \(/i, `INSERT INTO ${table} (`)
        lines.push(insertData)
        lines.push('')
      }
    } catch (error) {
      logWarning(`Could not export data for ${table}: ${error}`)
    }
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath)
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true })
  }

  // Write to file
  const content = lines.join('\n')
  await writeFile(outputPath, content, 'utf-8')

  const stats = await stat(outputPath)

  return {
    path: outputPath,
    format: 'sql',
    size: stats.size,
  }
}

/**
 * Create a native format backup (faster, more compact)
 * Note: Currently unused - SQL format is preferred for restore compatibility
 */
async function _createNativeBackup(
  container: ContainerConfig,
  outputPath: string,
  database: string,
): Promise<BackupResult> {
  const { port, version } = container

  const clickhousePath = await requireClickHousePath(version)

  // Ensure output directory exists
  const outputDir = dirname(outputPath)
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true })
  }

  // Get list of tables
  const tables = await getTables(clickhousePath, port, database)
  logDebug(`Found ${tables.length} tables to backup`)

  // Create a combined backup with all tables
  const fileStream = createWriteStream(outputPath)

  // Write header
  const header = `-- ClickHouse native backup\n-- Database: ${database}\n-- Date: ${new Date().toISOString()}\n\n`
  fileStream.write(header)

  for (const table of tables) {
    // Write table marker
    fileStream.write(`\n-- TABLE: ${table}\n`)

    // Get CREATE TABLE
    try {
      const createStmt = await getCreateTableStatement(
        clickhousePath,
        port,
        database,
        table,
      )
      fileStream.write(`-- CREATE:\n${createStmt};\n`)
    } catch (error) {
      logWarning(`Could not get CREATE TABLE for ${table}: ${error}`)
      continue
    }

    // Export data in Native format (binary, fast)
    fileStream.write(`-- DATA (Native format):\n`)

    await new Promise<void>((resolve, reject) => {
      const args = [
        'client',
        '--host',
        '127.0.0.1',
        '--port',
        String(port),
        '--database',
        database,
        '--query',
        `SELECT * FROM ${database}.${table} FORMAT Native`,
      ]

      const proc = spawn(clickhousePath, args, {
        stdio: ['ignore', 'pipe', 'pipe'],
      })

      let stderr = ''

      proc.stdout.pipe(fileStream, { end: false })

      proc.stderr.on('data', (data: Buffer) => {
        stderr += data.toString()
      })

      proc.on('error', reject)

      proc.on('close', (code) => {
        if (code === 0 || code === null) {
          resolve()
        } else {
          reject(new Error(stderr || `clickhouse client exited with code ${code}`))
        }
      })
    })

    fileStream.write('\n-- END TABLE\n')
  }

  // Close file
  await new Promise<void>((resolve, reject) => {
    fileStream.end((err: Error | null) => {
      if (err) reject(err)
      else resolve()
    })
  })

  const stats = await stat(outputPath)

  return {
    path: outputPath,
    format: 'native',
    size: stats.size,
  }
}

/**
 * Create a backup
 * Supports two formats:
 * - 'sql': SQL statements (DDL + INSERT)
 * - 'dump' (default): Native format (faster, more compact)
 */
export async function createBackup(
  container: ContainerConfig,
  outputPath: string,
  options: BackupOptions,
): Promise<BackupResult> {
  const database = options.database || container.database || 'default'

  // 'sql' format means SQL statements
  if (options.format === 'sql') {
    return createSqlBackup(container, outputPath, database)
  }
  // Default to SQL format since native format is complex for restore
  return createSqlBackup(container, outputPath, database)
}

/**
 * Create a backup for cloning purposes
 * Uses SQL format for reliability
 */
export async function createCloneBackup(
  container: ContainerConfig,
  outputPath: string,
): Promise<BackupResult> {
  return createSqlBackup(container, outputPath, container.database || 'default')
}
