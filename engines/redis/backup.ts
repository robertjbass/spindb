/**
 * Redis backup module
 * Supports two formats:
 * - RDB: Binary snapshot via BGSAVE (default, compact, fast restore)
 * - Text: Human-readable Redis commands (.redis file)
 */

import { exec } from 'child_process'
import { promisify } from 'util'
import { copyFile, stat, mkdir, writeFile } from 'fs/promises'
import { existsSync } from 'fs'
import { join, dirname } from 'path'
import { getRedisCliPath } from './binary-detection'
import { logDebug, logWarning } from '../../core/error-handler'
import { paths } from '../../config/paths'
import type { ContainerConfig, BackupOptions, BackupResult } from '../../types'

const execAsync = promisify(exec)

/**
 * Build a redis-cli command with proper shell escaping
 * Quotes arguments containing special shell characters
 */
function buildRedisCliCommand(
  redisCli: string,
  port: number,
  command: string,
): string {
  // Split command into parts and quote any parts containing shell special chars
  const parts = command.split(/\s+/)
  const quotedParts = parts.map((part) => {
    // If part contains shell special chars, wrap in single quotes
    if (/[*?[\]{}$`"'\\!<>|;&()]/.test(part)) {
      // Escape any single quotes in the part
      const escaped = part.replace(/'/g, "'\"'\"'")
      return `'${escaped}'`
    }
    return part
  })
  return `"${redisCli}" -h 127.0.0.1 -p ${port} ${quotedParts.join(' ')}`
}

/**
 * Escape a string value for Redis command output
 * Wraps in single quotes and escapes internal single quotes
 */
function escapeRedisValue(value: string): string {
  // Use single quotes and escape any internal single quotes
  return `'${value.replace(/'/g, "\\'")}'`
}

/**
 * Create a text-based backup (.redis file)
 * Exports all keys as Redis commands that can be replayed
 */
async function createTextBackup(
  container: ContainerConfig,
  outputPath: string,
): Promise<BackupResult> {
  const { port } = container

  const redisCli = await getRedisCliPath()
  if (!redisCli) {
    throw new Error(
      'redis-cli not found. Install Redis:\n' +
        '  macOS: brew install redis\n' +
        '  Ubuntu: sudo apt install redis-tools\n',
    )
  }

  const commands: string[] = []
  commands.push('# Redis backup generated by SpinDB')
  commands.push(`# Date: ${new Date().toISOString()}`)
  commands.push('')

  // Get all keys using KEYS * (for small datasets this is fine)
  // For production with millions of keys, SCAN would be better
  const keysCmd = buildRedisCliCommand(redisCli, port, 'KEYS *')
  const { stdout: keysOutput } = await execAsync(keysCmd)
  const keys = keysOutput.trim().split('\n').filter((k) => k.trim())

  logDebug(`Found ${keys.length} keys to backup`)

  for (const key of keys) {
    // Get key type
    const typeCmd = buildRedisCliCommand(redisCli, port, `TYPE ${key}`)
    const { stdout: typeOutput } = await execAsync(typeCmd)
    const keyType = typeOutput.trim()

    // Get TTL
    const ttlCmd = buildRedisCliCommand(redisCli, port, `TTL ${key}`)
    const { stdout: ttlOutput } = await execAsync(ttlCmd)
    const ttl = parseInt(ttlOutput.trim(), 10)

    switch (keyType) {
      case 'string': {
        const getCmd = buildRedisCliCommand(redisCli, port, `GET ${key}`)
        const { stdout: value } = await execAsync(getCmd)
        commands.push(`SET ${key} ${escapeRedisValue(value.trim())}`)
        break
      }
      case 'hash': {
        const hgetallCmd = buildRedisCliCommand(redisCli, port, `HGETALL ${key}`)
        const { stdout: hashData } = await execAsync(hgetallCmd)
        const lines = hashData.trim().split('\n').filter((l) => l.trim())
        if (lines.length >= 2) {
          const pairs: string[] = []
          for (let i = 0; i < lines.length; i += 2) {
            const field = lines[i].trim()
            const value = lines[i + 1]?.trim() || ''
            pairs.push(`${field} ${escapeRedisValue(value)}`)
          }
          commands.push(`HSET ${key} ${pairs.join(' ')}`)
        }
        break
      }
      case 'list': {
        const lrangeCmd = buildRedisCliCommand(redisCli, port, `LRANGE ${key} 0 -1`)
        const { stdout: listData } = await execAsync(lrangeCmd)
        const items = listData.trim().split('\n').filter((l) => l.trim())
        if (items.length > 0) {
          const escapedItems = items.map((item) => escapeRedisValue(item.trim()))
          commands.push(`RPUSH ${key} ${escapedItems.join(' ')}`)
        }
        break
      }
      case 'set': {
        const smembersCmd = buildRedisCliCommand(redisCli, port, `SMEMBERS ${key}`)
        const { stdout: setData } = await execAsync(smembersCmd)
        const members = setData.trim().split('\n').filter((l) => l.trim())
        if (members.length > 0) {
          const escapedMembers = members.map((m) => escapeRedisValue(m.trim()))
          commands.push(`SADD ${key} ${escapedMembers.join(' ')}`)
        }
        break
      }
      case 'zset': {
        const zrangeCmd = buildRedisCliCommand(
          redisCli,
          port,
          `ZRANGE ${key} 0 -1 WITHSCORES`,
        )
        const { stdout: zsetData } = await execAsync(zrangeCmd)
        const lines = zsetData.trim().split('\n').filter((l) => l.trim())
        if (lines.length >= 2) {
          const pairs: string[] = []
          for (let i = 0; i < lines.length; i += 2) {
            const member = lines[i].trim()
            const score = lines[i + 1]?.trim() || '0'
            pairs.push(`${score} ${escapeRedisValue(member)}`)
          }
          commands.push(`ZADD ${key} ${pairs.join(' ')}`)
        }
        break
      }
      default:
        logWarning(`Skipping key ${key} with unsupported type: ${keyType}`)
    }

    // Add EXPIRE if key has TTL
    if (ttl > 0) {
      commands.push(`EXPIRE ${key} ${ttl}`)
    }
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath)
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true })
  }

  // Write commands to file
  const content = commands.join('\n') + '\n'
  await writeFile(outputPath, content, 'utf-8')

  const stats = await stat(outputPath)

  return {
    path: outputPath,
    format: 'redis',
    size: stats.size,
  }
}

/**
 * Create a backup using BGSAVE (RDB format)
 *
 * Redis backups are RDB files (binary snapshots).
 * The backup process:
 * 1. Trigger BGSAVE command
 * 2. Poll LASTSAVE until timestamp changes (backup complete)
 * 3. Copy dump.rdb to output path
 */
async function createRdbBackup(
  container: ContainerConfig,
  outputPath: string,
): Promise<BackupResult> {
  const { port, name } = container

  const redisCli = await getRedisCliPath()
  if (!redisCli) {
    throw new Error(
      'redis-cli not found. Install Redis:\n' +
        '  macOS: brew install redis\n' +
        '  Ubuntu: sudo apt install redis-tools\n',
    )
  }

  // Trigger background save
  const bgsaveCmd = buildRedisCliCommand(redisCli, port, 'BGSAVE')
  let bgsaveResponse: string
  try {
    const { stdout, stderr } = await execAsync(bgsaveCmd)
    bgsaveResponse = stdout.trim()

    // Log stderr as warning if present (redis-cli may emit non-fatal warnings)
    // Actual errors are caught via non-zero exit code or Redis protocol errors in stdout
    if (stderr && stderr.trim()) {
      logWarning(`redis-cli stderr: ${stderr.trim()}`)
    }
  } catch (error) {
    // execAsync throws on non-zero exit code
    const execError = error as Error & { stderr?: string; code?: number }
    throw new Error(
      `BGSAVE command failed (exit code ${execError.code ?? 'unknown'}): ${execError.message}` +
        (execError.stderr ? `\nstderr: ${execError.stderr}` : ''),
    )
  }

  logDebug(`BGSAVE response: ${bgsaveResponse}`)

  // Check for Redis error responses in stdout
  // Redis returns errors like "ERR ..." or "(error) ..." in stdout
  if (
    bgsaveResponse.startsWith('ERR') ||
    bgsaveResponse.startsWith('(error)')
  ) {
    // Special case: if a save is already in progress, we can wait for it
    if (bgsaveResponse.includes('Background save already in progress')) {
      logDebug('BGSAVE already in progress, waiting for it to complete')
    } else {
      throw new Error(`BGSAVE failed: ${bgsaveResponse}`)
    }
  } else if (
    !bgsaveResponse.includes('Background saving started') &&
    !bgsaveResponse.includes('Background save already in progress')
  ) {
    // Unexpected response - warn but continue (might be a different Redis version)
    logDebug(`Unexpected BGSAVE response (continuing anyway): ${bgsaveResponse}`)
  }

  // Wait for save to complete by checking rdb_bgsave_in_progress
  // This is more reliable than LASTSAVE timestamp which has 1-second resolution
  const startTime = Date.now()
  const timeout = 60000 // 1 minute timeout

  const infoCmd = buildRedisCliCommand(
    redisCli,
    port,
    'INFO persistence',
  )

  while (Date.now() - startTime < timeout) {
    const { stdout: infoOutput } = await execAsync(infoCmd)

    // Check if BGSAVE is still in progress
    const inProgress = infoOutput.includes('rdb_bgsave_in_progress:1')
    if (!inProgress) {
      // Also check for errors
      const statusMatch = infoOutput.match(/rdb_last_bgsave_status:(\w+)/)
      const status = statusMatch?.[1]
      if (status === 'err') {
        throw new Error('BGSAVE failed. Check Redis logs for details.')
      }
      logDebug('BGSAVE completed successfully')
      break
    }

    await new Promise((r) => setTimeout(r, 100))
  }

  if (Date.now() - startTime >= timeout) {
    throw new Error('BGSAVE timed out after 60 seconds')
  }

  // Get the RDB file path from Redis data directory
  const dataDir = paths.getContainerDataPath(name, { engine: 'redis' })
  const rdbPath = join(dataDir, 'dump.rdb')

  if (!existsSync(rdbPath)) {
    throw new Error(
      `RDB file not found at ${rdbPath} after BGSAVE. Check Redis configuration.`,
    )
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath)
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true })
  }

  // Copy RDB file to output path
  await copyFile(rdbPath, outputPath)

  const stats = await stat(outputPath)

  return {
    path: outputPath,
    format: 'rdb',
    size: stats.size,
  }
}

/**
 * Create a backup
 * Supports two formats:
 * - 'sql' (actually .redis): Text-based Redis commands
 * - 'dump' (default): Binary RDB snapshot
 */
export async function createBackup(
  container: ContainerConfig,
  outputPath: string,
  options: BackupOptions,
): Promise<BackupResult> {
  // 'sql' format means text-based commands for Redis
  if (options.format === 'sql') {
    return createTextBackup(container, outputPath)
  }
  // Default to RDB format
  return createRdbBackup(container, outputPath)
}

/**
 * Create a backup for cloning purposes
 * Always uses RDB format for speed and reliability
 */
export async function createCloneBackup(
  container: ContainerConfig,
  outputPath: string,
): Promise<BackupResult> {
  return createRdbBackup(container, outputPath)
}
