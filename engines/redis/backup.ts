/**
 * Redis backup module
 * Supports two formats:
 * - RDB: Binary snapshot via BGSAVE (default, compact, fast restore)
 * - Text: Human-readable Redis commands (.redis file)
 */

import { spawn } from 'child_process'
import { copyFile, stat, mkdir, writeFile } from 'fs/promises'
import { existsSync } from 'fs'
import { join, dirname } from 'path'
import { logDebug, logWarning } from '../../core/error-handler'
import { paths } from '../../config/paths'
import { getRedisCliPath, REDIS_CLI_NOT_FOUND_ERROR } from './cli-utils'
import type { ContainerConfig, BackupOptions, BackupResult } from '../../types'

/**
 * Execute a Redis command via stdin piping
 * This is safer than shell command construction as it handles
 * keys/values with spaces and special characters correctly
 */
async function execRedisCommand(
  redisCli: string,
  port: number,
  command: string,
): Promise<string> {
  return new Promise((resolve, reject) => {
    const proc = spawn(redisCli, ['-h', '127.0.0.1', '-p', String(port)], {
      stdio: ['pipe', 'pipe', 'pipe'],
    })

    let stdout = ''
    let stderr = ''

    proc.stdout.on('data', (data: Buffer) => {
      stdout += data.toString()
    })
    proc.stderr.on('data', (data: Buffer) => {
      stderr += data.toString()
    })

    proc.on('error', reject)

    proc.on('close', (code) => {
      if (code === 0 || code === null) {
        resolve(stdout)
      } else {
        reject(new Error(stderr || `redis-cli exited with code ${code}`))
      }
    })

    // Write command to stdin and close
    proc.stdin.write(command + '\n')
    proc.stdin.end()
  })
}

/**
 * Escape a string value for Redis command output
 * Wraps in single quotes and escapes internal single quotes
 */
function escapeRedisValue(value: string): string {
  // Use single quotes and escape any internal single quotes
  return `'${value.replace(/'/g, "\\'")}'`
}

/**
 * Create a text-based backup (.redis file)
 * Exports all keys as Redis commands that can be replayed
 */
async function createTextBackup(
  container: ContainerConfig,
  outputPath: string,
): Promise<BackupResult> {
  const { port } = container

  const redisCli = await getRedisCliPath()
  if (!redisCli) {
    throw new Error(REDIS_CLI_NOT_FOUND_ERROR)
  }

  const commands: string[] = []
  commands.push('# Redis backup generated by SpinDB')
  commands.push(`# Date: ${new Date().toISOString()}`)
  commands.push('')

  // Get all keys using KEYS * (for small datasets this is fine)
  // For production with millions of keys, SCAN would be better
  const keysOutput = await execRedisCommand(redisCli, port, 'KEYS *')
  // Use /\r?\n/ to handle both Unix (\n) and Windows (\r\n) line endings
  const keys = keysOutput
    .trim()
    .split(/\r?\n/)
    .map((k) => k.trim())
    .filter((k) => k)

  logDebug(`Found ${keys.length} keys to backup`)

  for (const key of keys) {
    // Get key type - quote key to handle spaces/special chars
    const typeOutput = await execRedisCommand(
      redisCli,
      port,
      `TYPE "${key.replace(/"/g, '\\"')}"`,
    )
    const keyType = typeOutput.trim()

    // Get TTL
    const ttlOutput = await execRedisCommand(
      redisCli,
      port,
      `TTL "${key.replace(/"/g, '\\"')}"`,
    )
    const ttl = parseInt(ttlOutput.trim(), 10)

    // Quote the key for output commands
    const quotedKey = key.includes(' ') || /[*?[\]{}$`"'\\!<>|;&()]/.test(key)
      ? `"${key.replace(/"/g, '\\"')}"`
      : key

    switch (keyType) {
      case 'string': {
        const value = await execRedisCommand(
          redisCli,
          port,
          `GET "${key.replace(/"/g, '\\"')}"`,
        )
        commands.push(`SET ${quotedKey} ${escapeRedisValue(value.trim())}`)
        break
      }
      case 'hash': {
        const hashData = await execRedisCommand(
          redisCli,
          port,
          `HGETALL "${key.replace(/"/g, '\\"')}"`,
        )
        const lines = hashData
          .trim()
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l)
        if (lines.length >= 2) {
          const pairs: string[] = []
          for (let i = 0; i < lines.length; i += 2) {
            const field = lines[i].trim()
            const value = lines[i + 1]?.trim() || ''
            // Quote field if it contains special chars
            const quotedField = field.includes(' ') || /[*?[\]{}$`"'\\!<>|;&()]/.test(field)
              ? `"${field.replace(/"/g, '\\"')}"`
              : field
            pairs.push(`${quotedField} ${escapeRedisValue(value)}`)
          }
          commands.push(`HSET ${quotedKey} ${pairs.join(' ')}`)
        }
        break
      }
      case 'list': {
        const listData = await execRedisCommand(
          redisCli,
          port,
          `LRANGE "${key.replace(/"/g, '\\"')}" 0 -1`,
        )
        const items = listData
          .trim()
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l)
        if (items.length > 0) {
          const escapedItems = items.map((item) =>
            escapeRedisValue(item.trim()),
          )
          commands.push(`RPUSH ${quotedKey} ${escapedItems.join(' ')}`)
        }
        break
      }
      case 'set': {
        const setData = await execRedisCommand(
          redisCli,
          port,
          `SMEMBERS "${key.replace(/"/g, '\\"')}"`,
        )
        const members = setData
          .trim()
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l)
        if (members.length > 0) {
          const escapedMembers = members.map((m) => escapeRedisValue(m.trim()))
          commands.push(`SADD ${quotedKey} ${escapedMembers.join(' ')}`)
        }
        break
      }
      case 'zset': {
        const zsetData = await execRedisCommand(
          redisCli,
          port,
          `ZRANGE "${key.replace(/"/g, '\\"')}" 0 -1 WITHSCORES`,
        )
        const lines = zsetData
          .trim()
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l)
        if (lines.length >= 2) {
          const pairs: string[] = []
          for (let i = 0; i < lines.length; i += 2) {
            const member = lines[i].trim()
            const score = lines[i + 1]?.trim() || '0'
            pairs.push(`${score} ${escapeRedisValue(member)}`)
          }
          commands.push(`ZADD ${quotedKey} ${pairs.join(' ')}`)
        }
        break
      }
      default:
        logWarning(`Skipping key ${key} with unsupported type: ${keyType}`)
    }

    // Add EXPIRE if key has TTL
    if (ttl > 0) {
      commands.push(`EXPIRE ${quotedKey} ${ttl}`)
    }
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath)
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true })
  }

  // Write commands to file
  const content = commands.join('\n') + '\n'
  await writeFile(outputPath, content, 'utf-8')

  const stats = await stat(outputPath)

  return {
    path: outputPath,
    format: 'redis',
    size: stats.size,
  }
}

/**
 * Create a backup using BGSAVE (RDB format)
 *
 * Redis backups are RDB files (binary snapshots).
 * The backup process:
 * 1. Trigger BGSAVE command
 * 2. Poll LASTSAVE until timestamp changes (backup complete)
 * 3. Copy dump.rdb to output path
 */
async function createRdbBackup(
  container: ContainerConfig,
  outputPath: string,
): Promise<BackupResult> {
  const { port, name } = container

  const redisCli = await getRedisCliPath()
  if (!redisCli) {
    throw new Error(REDIS_CLI_NOT_FOUND_ERROR)
  }

  // Trigger background save
  let bgsaveResponse: string
  try {
    bgsaveResponse = await execRedisCommand(redisCli, port, 'BGSAVE')
    bgsaveResponse = bgsaveResponse.trim()
  } catch (error) {
    const execError = error as Error
    throw new Error(`BGSAVE command failed: ${execError.message}`)
  }

  logDebug(`BGSAVE response: ${bgsaveResponse}`)

  // Check for Redis error responses in stdout
  // Redis returns errors like "ERR ..." or "(error) ..." in stdout
  if (
    bgsaveResponse.startsWith('ERR') ||
    bgsaveResponse.startsWith('(error)')
  ) {
    // Special case: if a save is already in progress, we can wait for it
    if (bgsaveResponse.includes('Background save already in progress')) {
      logDebug('BGSAVE already in progress, waiting for it to complete')
    } else {
      throw new Error(`BGSAVE failed: ${bgsaveResponse}`)
    }
  } else if (
    !bgsaveResponse.includes('Background saving started') &&
    !bgsaveResponse.includes('Background save already in progress')
  ) {
    // Unexpected response - warn but continue (might be a different Redis version)
    logDebug(
      `Unexpected BGSAVE response (continuing anyway): ${bgsaveResponse}`,
    )
  }

  // Wait for save to complete by checking rdb_bgsave_in_progress
  // This is more reliable than LASTSAVE timestamp which has 1-second resolution
  const startTime = Date.now()
  const timeout = 60000 // 1 minute timeout

  while (Date.now() - startTime < timeout) {
    const infoOutput = await execRedisCommand(redisCli, port, 'INFO persistence')

    // Check if BGSAVE is still in progress
    const inProgress = infoOutput.includes('rdb_bgsave_in_progress:1')
    if (!inProgress) {
      // Also check for errors
      const statusMatch = infoOutput.match(/rdb_last_bgsave_status:(\w+)/)
      const status = statusMatch?.[1]
      if (status === 'err') {
        throw new Error('BGSAVE failed. Check Redis logs for details.')
      }
      logDebug('BGSAVE completed successfully')
      break
    }

    await new Promise((r) => setTimeout(r, 100))
  }

  if (Date.now() - startTime >= timeout) {
    throw new Error('BGSAVE timed out after 60 seconds')
  }

  // Get the RDB file path from Redis data directory
  const dataDir = paths.getContainerDataPath(name, { engine: 'redis' })
  const rdbPath = join(dataDir, 'dump.rdb')

  if (!existsSync(rdbPath)) {
    throw new Error(
      `RDB file not found at ${rdbPath} after BGSAVE. Check Redis configuration.`,
    )
  }

  // Ensure output directory exists
  const outputDir = dirname(outputPath)
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true })
  }

  // Copy RDB file to output path
  await copyFile(rdbPath, outputPath)

  const stats = await stat(outputPath)

  return {
    path: outputPath,
    format: 'rdb',
    size: stats.size,
  }
}

/**
 * Create a backup
 * Supports two formats:
 * - 'sql' (actually .redis): Text-based Redis commands
 * - 'dump' (default): Binary RDB snapshot
 */
export async function createBackup(
  container: ContainerConfig,
  outputPath: string,
  options: BackupOptions,
): Promise<BackupResult> {
  // 'sql' format means text-based commands for Redis
  if (options.format === 'sql') {
    return createTextBackup(container, outputPath)
  }
  // Default to RDB format
  return createRdbBackup(container, outputPath)
}

/**
 * Create a backup for cloning purposes
 * Always uses RDB format for speed and reliability
 */
export async function createCloneBackup(
  container: ContainerConfig,
  outputPath: string,
): Promise<BackupResult> {
  return createRdbBackup(container, outputPath)
}
